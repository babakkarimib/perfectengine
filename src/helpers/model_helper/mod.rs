use std::env;
use async_std::fs;
use crate::{graphics::cpu::operations::Operations, types::pixel::Pixel};

pub struct ModelHelper {}

impl ModelHelper {
    pub async fn load_msh_file_with_texture() -> (Vec<Pixel>, usize) {
        // Open the .msh file generated by executing "gmsh mesh_script.geo" in the command line
        let mut pixels: Vec<Pixel> = vec![];
        let current_dir = env::current_dir().expect("Failed to get current directory");
        
        let mesh_file_path = current_dir.join("src").join("helpers").join("model_helper").join("mesh_output.msh");
        let msh_bytes = fs::read(mesh_file_path).await.unwrap();
        let parser_result = mshio::parse_msh_bytes(msh_bytes.as_slice());

        let texture_file_path = current_dir.join("src").join("helpers").join("model_helper").join("texture.png");
        let img = fs::read(texture_file_path).await.expect("Failed to read image");
        let img = image::load_from_memory(&img).expect("Failed to decode image").to_rgba8();
    
        let mut count = 0;

        if let Some(nodes) = parser_result.unwrap().data.nodes {
            for node_block in nodes.node_blocks {
                for node in node_block.nodes {
                    let x = node.x as f32;
                    let y = node.y as f32;
                    let z = node.z as f32;

                    let (tx, ty) = Operations::project(300.0, 200.0, 800.0, 800.0, x, y, z);
                    
                    let rgba = img.get_pixel(tx, ty);
    
                    pixels.push(Pixel {
                        x,
                        y,
                        z,
                        r: rgba[0] as f32 / 255.0,
                        g: rgba[1] as f32 / 255.0,
                        b: rgba[2] as f32 / 255.0,
                        a: rgba[3] as f32 / 255.0,
                        size_factor: 1.7,
                    });

                    count += 1;
                }
            }
        }
    
        (pixels, count)
    }
}
