use std::env;
use async_std::fs;
use image::GenericImageView;
use crate::{graphics::cpu::operations::Operations, types::{pixel::Pixel, view_state::ViewState}};

pub async fn load_msh_file_with_texture() -> (Vec<Pixel>, usize) {
    // Open the .msh file generated by executing "gmsh mesh_script.geo" in the command line
    let mut pixels: Vec<Pixel> = vec![];
    let current_dir = env::current_dir().expect("Failed to get current directory");
    
    let mesh_file_path = current_dir.join("src").join("helpers").join("model_helper").join("mesh_output.msh");
    let msh_bytes = fs::read(mesh_file_path).await.unwrap();
    let parser_result = mshio::parse_msh_bytes(msh_bytes.as_slice());

    let texture_file_path = current_dir.join("src").join("helpers").join("model_helper").join("texture.png");
    let img = fs::read(texture_file_path).await.expect("Failed to read image");
    let img = image::load_from_memory(&img).expect("Failed to decode image").to_rgba8();

    let width = 800.0;
    let height = 800.0;

    let mut count = 0;

    if let Some(nodes) = parser_result.unwrap().data.nodes {
        for node_block in nodes.node_blocks {
            for node in node_block.nodes {
                let x = node.x as f32;
                let y = node.y as f32;
                let z = node.z as f32;

                let angle_x: f32 = -89.75;
                let angle_y: f32 = 0.0;
                let (rx, ry, rz) = Operations::rotate(angle_x.sin(), angle_y.sin(), angle_x.cos(), angle_y.cos(), x, y, z);
                let (tx, ty) = Operations::project(280.0, 220.0, width, height, rx, ry, rz);
                let rgba = img.get_pixel(tx, ty);

                pixels.push(Pixel {
                    x: rx,
                    y: ry,
                    z: rz,
                    r: rgba[0] as f32 / 255.0,
                    g: rgba[1] as f32 / 255.0,
                    b: rgba[2] as f32 / 255.0,
                    a: rgba[3] as f32 / 255.0,
                    size_factor: 1.8,
                });

                count += 1;
            }
        }
    }

    let view_state = ViewState { angle_x: 0.0, angle_y: 0.0, scale: 280.0, distance: 220.0 };
    load_texture(&mut pixels, count, view_state, width, height, "flower.png").await;

    let view_state = ViewState { angle_x: 0.45, angle_y: 85.0, scale: 280.0, distance: 220.0 };
    load_texture(&mut pixels, count, view_state, width, height, "flower.png").await;

    (pixels, count)
}

async fn load_texture(pixels: &mut Vec<Pixel>, count: usize, view_state: ViewState, width: f32, height: f32, path: &str) {
    let current_dir = env::current_dir().expect("Failed to get current directory");
    let texture_file_path = current_dir.join("src").join("helpers").join("model_helper").join(path);
    let img = fs::read(texture_file_path).await.expect("Failed to read image");
    let img = image::load_from_memory(&img).expect("Failed to decode image").to_rgba8();
    
    let (f_width, f_height) = img.dimensions();
    let w_disposition = (width as u32 / 2) - (f_width / 2);
    let h_disposition = (height as u32 / 2) - (f_height / 2) + 60;

    let ViewState {
        angle_x,
        angle_y,
        scale,
        distance,
    } = view_state;

    for i in 0..count {
        let pixel = &mut pixels[i];

        let (rx, ry, rz) = Operations::rotate(angle_x.sin(), angle_y.sin(), angle_x.cos(), angle_y.cos(), pixel.x, pixel.y, pixel.z);
        let (tx, ty) = Operations::project(scale, distance, width, height, rx, ry, rz);

        if rz < 0.0 && img.in_bounds(tx - w_disposition, ty - h_disposition) {
            let rgba = img.get_pixel(tx - w_disposition, ty - h_disposition);
            if rgba[3] != 0 {
                pixel.r = rgba[0] as f32 / 255.0;
                pixel.g = rgba[1] as f32 / 255.0;
                pixel.b = rgba[2] as f32 / 255.0;
                pixel.a = rgba[3] as f32 / 255.0;
            }
        }
    }
}
