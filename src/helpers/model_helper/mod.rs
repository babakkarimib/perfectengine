use std::env;
use async_std::fs;
use crate::types::pixel::Pixel;

pub struct ModelHelper {}

impl ModelHelper {
    pub async fn load_msh_file_with_texture() -> (Vec<Pixel>, usize) {
        // Open the .msh file generated by executing "gmsh mesh_script.geo" in the command line
        let mut pixels: Vec<Pixel> = vec![];
        let current_dir = env::current_dir().expect("Failed to get current directory");
        
        let mesh_file_path = current_dir.join("src").join("helpers").join("model_helper").join("mesh_output.msh");
        let msh_bytes = fs::read(mesh_file_path).await.unwrap();
        let parser_result = mshio::parse_msh_bytes(msh_bytes.as_slice());

        let texture_file_path = current_dir.join("src").join("helpers").join("model_helper").join("texture.png");
        let img = fs::read(texture_file_path).await.expect("Failed to read image");
        let img = image::load_from_memory(&img).expect("Failed to decode image").to_rgba8();
        let (width, height) = img.dimensions();
    
        let mut count = 0;

        if let Some(nodes) = parser_result.unwrap().data.nodes {
            for node_block in nodes.node_blocks {
                for node in node_block.nodes {
                    let x = node.x as f32;
                    let y = node.y as f32;
                    let z = node.z as f32;

                    let tx = (count % width as usize) as u32;
                    let ty = (count % height as usize) as u32;
                    
                    let rgba = img.get_pixel(tx, ty);
    
                    pixels.push(Pixel {
                        x,
                        y,
                        z,
                        r: rgba.0[0] as f32 / 255.0,
                        g: rgba.0[1] as f32 / 255.0,
                        b: rgba.0[2] as f32 / 255.0,
                        a: 1.0,
                        size_factor: 1.7,
                    });

                    count += 1;
                }
            }
        }
    
        (pixels, count)
    }
}
