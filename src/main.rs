mod types;
mod graphics;
mod events;
mod helpers;

use std::time::{Duration, Instant};
use async_std::print;
use async_std::task;
use graphics::gpu_renderer::GpuRenderer;
use regex::Regex;
use std::env;

use types::{view_state::ViewState, light::Light, event_callback::EventCallback};
use events::event_handler::EventHandler;

const DEFAULT_WIDTH: u32 = 800;
const DEFAULT_HEIGHT: u32 = 600;
const SCALE: f32 = 1000.0;

const FPS: u32 = 60;
const FRAME_DURATION: Duration = Duration::from_millis(1000 / FPS as u64);

#[async_std::main]
async fn main() {
    let mut framerate_log = false;
    let mut fullscreen = false;
    let mut width: Option<u32> = None;
    let mut height: Option<u32> = None;

    let width_regex = Regex::new(r"^w=(\d+)$").unwrap();
    let height_regex = Regex::new(r"^h=(\d+)$").unwrap();

    let args: Vec<String> = env::args().collect();
    for i in 1..args.len() {
        if let Some(arg) = args.get(i) {
            match arg.as_str() {
                "framerate" => framerate_log = true,
                "fullscreen" => fullscreen = true,
                _ if width_regex.is_match(arg) => {
                    if let Some(caps) = width_regex.captures(arg) {
                        width = caps.get(1).map(|m| m.as_str().parse().unwrap());
                    }
                }
                _ if height_regex.is_match(arg) => {
                    if let Some(caps) = height_regex.captures(arg) {
                        height = caps.get(1).map(|m| m.as_str().parse().unwrap());
                    }
                }
                _ => panic!("Invalid argument: {}. Please use 'framerate', 'fullscreen', 'w={{}}', or 'h={{}}'.", arg),
            }
        }
    }

    let sdl_context = sdl2::init().unwrap();
    let video_subsystem = sdl_context.video().unwrap();
    let display_mode = video_subsystem.desktop_display_mode(0).unwrap();

    let width = if let Some(w) = width {w} else { if fullscreen { display_mode.w as u32 } else {DEFAULT_WIDTH} };
    let height = if let Some(h) = height {h} else { if fullscreen { display_mode.h as u32 } else {DEFAULT_HEIGHT} };

    let window = if fullscreen {
        video_subsystem.window("Perfect Engine", width, height)
        .fullscreen()
        .build()
        .unwrap()
    } else {
        video_subsystem.window("Perfect Engine", width, height)
        .position_centered()
        .resizable()
        .build()
        .unwrap()
    };

    let mut renderer = GpuRenderer::new(&window).await;

    let mut pixel_count = 0;
    let (pixels, count) = helpers::test_helper::generate_cube_pixels(1, 100000, 20.0);
    pixel_count += count;
    renderer.load_pixels(pixels);

    // Opens the .msh file generated by running "gmsh mesh_script.geo" in the command-line in "/helpers/model_helper" directory (after installing gmsh) 
    // Output is big and takes time to generate
    let (pixels, count) = helpers::model_helper::load_msh_file_with_texture(2).await;
    pixel_count += count;
    renderer.load_pixels(pixels);

    // TODO:
    // - Save pixels of an object without id in a JSON file
    // - Save a scene as a list of id, filename, position, rotation of the objects in the scene in a JSON file
    // - Construct each object by reading the properties stored in a scene and then load the pixels using the filename and id

    let event_pump = sdl_context.event_pump().unwrap();
    let mut event_handler = EventHandler::new(event_pump);

    let mut view_state = ViewState { 
        angle_x: 0.0,
        angle_y: 0.0,
        angle_z: 0.0,
        c_angle_x: 0.0,
        c_angle_y: 0.0,
        c_angle_z: 0.0,
        camera_x: 0.0,
        camera_y: 0.0,
        camera_z: 700.0,
        ref_x: 0.0,
        ref_y: 0.0,
        ref_z: 0.0,
        z_offset: 50.0,
        scale: SCALE,
    };
    let mut light = Light {
        x: 0.0,
        y: 0.0,
        z: 100.0,
        intensity: 50.0,
    };

    println!("\nFULLSCREEN:   {}\t\tWIDTH: {}\t\tHEIGHT: {}", fullscreen, width, height);
    println!("FPS LIMIT: {:5}\t\tPIXEL COUNT: {:10}", FPS, pixel_count);
    'running: loop {
        let process_start = Instant::now();

        let event_callback = event_handler.handle_events(&mut view_state, &mut light);
        match event_callback {
            Some(EventCallback::Quit) => break 'running,
            Some(EventCallback::Resized(w, h)) => {
                renderer.resize(w, h);
                view_state.scale = SCALE * (w as f32 / width as f32).min(h as f32 / height as f32);
            },
            None => {}
        }

        // Experimental animation
        view_state.angle_y += 0.05;

        renderer.render(&view_state, &light);

        let process_duration = process_start.elapsed();
        if framerate_log {
            print!("\rFRAME TIME: {:4}ms\t\tFRAME RATE: {:4}", process_duration.as_millis(), 1000 / process_duration.as_millis()).await;
        }
        if process_duration < FRAME_DURATION {
            task::sleep(FRAME_DURATION - process_duration).await;
        }
    }
}
